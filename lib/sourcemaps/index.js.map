{"version":3,"sources":["index.js","index.ts"],"names":["__decorate","decorators","target","key","desc","d","c","arguments","length","r","Object","getOwnPropertyDescriptor","Reflect","_typeof","decorate","i","defineProperty","__metadata","k","v","metadata","path","require","development_core_1","_","cache","ts","sourcemaps","uglify","babel","TsCompile","info","_classCallCheck","this","_possibleConstructorReturn","__proto__","getPrototypeOf","call","_inherits","_development_core_1$P","_createClass","value","name","source","ctx","dist","gulp","getInfo","src","getSrc","pipe","init","getTsProject","oper","Operation","build","extend","nonePipe","pipes","option","babelOption","presets","write","sourceMaps","isUndefined","splice","deploy","release","toTransform","isBoolean","tsconfig","tsProject","createProject","join","env","root","tsconfigFile","PipeTask","task","default","autoWatch","exports"],"mappings":"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","file":"../index.js","sourcesContent":["\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nconst path = require('path');\nconst development_core_1 = require('development-core');\nconst _ = require('lodash');\n// import * as chalk from 'chalk';\nconst cache = require('gulp-cached');\nconst ts = require('gulp-typescript');\nconst sourcemaps = require('gulp-sourcemaps');\nconst uglify = require('gulp-uglify');\nconst babel = require('gulp-babel');\nlet TsCompile = class TsCompile extends development_core_1.PipeTask {\n    constructor(info) {\n        super(info);\n    }\n    getInfo() {\n        this.info.name = this.info.name || 'tscompile';\n        return this.info;\n    }\n    source(ctx, dist, gulp) {\n        let info = this.getInfo();\n        let source = gulp.src(ctx.getSrc(info))\n            .pipe(cache('typescript'))\n            .pipe(sourcemaps.init())\n            .pipe(this.getTsProject(ctx));\n        if (ctx.oper & development_core_1.Operation.build) {\n            return source['js'];\n        }\n        else {\n            return [\n                source['js'],\n                _.extend(source['dts'], { nonePipe: true })\n            ];\n        }\n    }\n    pipes(ctx, dist, gulp) {\n        let option = ctx.option;\n        let pipes = [\n                (ctx) => babel(option.babelOption || { presets: ['es2015'] }),\n                (ctx) => sourcemaps.write(option.sourceMaps || './sourcemaps')\n        ];\n        if (_.isUndefined(option.uglify)) {\n            option.uglify = true;\n        }\n        if (option.uglify) {\n            pipes.splice(1, 0, {\n                oper: development_core_1.Operation.deploy | development_core_1.Operation.release,\n                toTransform: (ctx) => _.isBoolean(option.uglify) ? uglify() : uglify(option.uglify)\n            });\n        }\n        return pipes;\n    }\n    getTsProject(ctx) {\n        let option = ctx.option;\n        if (option.tsconfig) {\n            return ts(option.tsconfig);\n        }\n        else {\n            let tsProject = ts.createProject(path.join(ctx.env.root || '', option.tsconfigFile || './tsconfig.json'));\n            return tsProject();\n        }\n    }\n};\nTsCompile = __decorate([\n    development_core_1.task({\n        oper: development_core_1.Operation.default | development_core_1.Operation.autoWatch\n    }), \n    __metadata('design:paramtypes', [Object])\n], TsCompile);\nexports.TsCompile = TsCompile;\n","import * as path from 'path';\r\nimport { Gulp } from 'gulp';\r\nimport {\r\n    Operation, IAssertDist, IAsserts, ITaskInfo, PipeTask, IOperate, Pipe\r\n    , TransformSource, task, ITaskContext, ITransform\r\n} from 'development-core';\r\nimport * as _ from 'lodash';\r\n// import * as chalk from 'chalk';\r\nconst cache = require('gulp-cached');\r\nconst ts = require('gulp-typescript');\r\nconst sourcemaps = require('gulp-sourcemaps');\r\nconst uglify = require('gulp-uglify');\r\nconst babel = require('gulp-babel');\r\n\r\n\r\n/**\r\n * typescript assert task option.\r\n * \r\n * @export\r\n * @interface ITsTaskOption\r\n * @extends {IAsserts}\r\n */\r\nexport interface ITsTaskOption extends IAsserts {\r\n    /**\r\n     * ts tsconfig.json file path.\r\n     * \r\n     * @type {sring}\r\n     * @memberOf ITsTaskOption\r\n     */\r\n    tsconfigFile?: string;\r\n    /**\r\n     * ts compile ctx.\r\n     * \r\n     * @type {*}\r\n     * @memberOf ITsTaskOption\r\n     */\r\n    tsconfig?: any;\r\n\r\n    /**\r\n     * zip compile js.\r\n     * \r\n     * @type {(boolean | Object)}\r\n     * @memberOf ITsTaskOption\r\n     */\r\n    uglify?: boolean | Object;\r\n\r\n    /**\r\n     * babel 6 option.\r\n     * \r\n     * @type {*}\r\n     * @memberOf ITsTaskOption\r\n     */\r\n    babelOption: any;\r\n\r\n    /**\r\n     * sourceMaps path.\r\n     * \r\n     * @type {string}\r\n     * @memberOf ITsTaskOption\r\n     */\r\n    sourceMaps?: string;\r\n}\r\n\r\n\r\n@task({\r\n    oper: Operation.default | Operation.autoWatch\r\n})\r\nexport class TsCompile extends PipeTask {\r\n    constructor(info: ITaskInfo) {\r\n        super(info)\r\n    }\r\n\r\n    getInfo() {\r\n        this.info.name = this.info.name || 'tscompile';\r\n        return this.info;\r\n    }\r\n\r\n    source(ctx: ITaskContext, dist: IAssertDist, gulp: Gulp): TransformSource | Promise<TransformSource> {\r\n        let info = this.getInfo();\r\n        let source = gulp.src(ctx.getSrc(info))\r\n            .pipe(cache('typescript'))\r\n            .pipe(sourcemaps.init())\r\n            .pipe(this.getTsProject(ctx));\r\n\r\n        if (ctx.oper & Operation.build) {\r\n            return source['js'];\r\n        } else {\r\n            return [\r\n                source['js'],\r\n                _.extend(source['dts'], <IOperate>{ nonePipe: true })\r\n            ]\r\n        }\r\n\r\n    }\r\n\r\n    pipes(ctx: ITaskContext, dist: IAssertDist, gulp?: Gulp): Pipe[] {\r\n        let option = <ITsTaskOption>ctx.option;\r\n        let pipes: Pipe[] = [\r\n            (ctx) => babel(option.babelOption || { presets: ['es2015'] }),\r\n            (ctx) => sourcemaps.write(option.sourceMaps || './sourcemaps')\r\n        ];\r\n\r\n        if (_.isUndefined(option.uglify)) {\r\n            option.uglify = true;\r\n        }\r\n        if (option.uglify) {\r\n            pipes.splice(1, 0, {\r\n                oper: Operation.deploy | Operation.release,\r\n                toTransform: (ctx) => _.isBoolean(option.uglify) ? uglify() : uglify(option.uglify)\r\n            });\r\n        }\r\n        return pipes;\r\n    }\r\n\r\n    private getTsProject(ctx: ITaskContext): ITransform {\r\n        let option = <ITsTaskOption>ctx.option;\r\n        if (option.tsconfig) {\r\n            return ts(option.tsconfig);\r\n        } else {\r\n            let tsProject = ts.createProject(path.join(ctx.env.root || '', option.tsconfigFile || './tsconfig.json'));\r\n            return tsProject();\r\n        }\r\n    }\r\n}\r\n"]}